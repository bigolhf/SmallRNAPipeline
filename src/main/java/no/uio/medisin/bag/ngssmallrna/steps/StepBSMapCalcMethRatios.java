/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package no.uio.medisin.bag.ngssmallrna.steps;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import no.uio.medisin.bag.core.SimpleSeq;
import no.uio.medisin.bag.ngssmallrna.pipeline.GrepFile;
import no.uio.medisin.bag.ngssmallrna.pipeline.ReferenceDataLocations;
import no.uio.medisin.bag.ngssmallrna.pipeline.SampleDataEntry;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;

import org.apache.logging.log4j.Logger;




/**
 *  calculate methylation ratios for alignment files generated by the BSMap mapping step
 * 
 *   Input is a BAM file
 *   Output is a methylation report
 * 
 * 
 * @author sr
 */

public class StepBSMapCalcMethRatios extends NGSStep implements NGSBase{
    
    private static Logger               logger                      = LogManager.getLogger();
    
    public static final String         STEP_ID_STRING              = "BSMapCalcMethRatio";

    private static final String         ID_SOFTWARE                 = "pathToBSmethRatio";
    private static final String         ID_REF_GENOME               = "host";
    private static final String         ID_OUTPUT_WIGGLE_FILE       = "outputWiggleFile";
    private static final String         ID_OUTPUT_WIGGLE_BINSIZE    = "wiggleFileBinSize";
    private static final String         ID_PROCESS_THESE_CHRS       = "processTheseChromosomes";
    private static final String         ID_PATH_TO_SAMTOOLS         = "pathToSAMTools";
    private static final String         ID_UNIQUE_MAPPINGS_ONLY     = "onlyProcessUniqueMappings";
    private static final String         ID_PAIRED_MAPPINGS_ONLY     = "onlyProcessPairedMappings";
    private static final String         ID_QUIET_MODE               = "quietMode";
    private static final String         ID_REMOVE_DUPLICATE_READS   = "removeDuplicateReads";
    private static final String         ID_TRIM_FILL_IN_NTS         = "trimNfillInNucleotides";
    private static final String         ID_COMBINE_STRANDS          = "combineCPGsFromBothStrands";
    private static final String         ID_MIN_DEPTH_COVERAGE       = "minDepthCoverage";
    private static final String         ID_NO_HEADER                = "noHeader";
    private static final String         ID_CT_SNP_ACTION            = "ctSnpAction";
    private static final String         ID_METHYLATION_PATTERNS     = "methylation_patterns";
    
    
    
    
    private static final String         INFILE_EXTENSION            = ".sam";
    
    private static final String         METHFILE_EXTENSION          = ".methylation_ratios.tsv";
    private static final String         WIGGLEFILE_EXTENSION        = ".wiggle";

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    /**
     * @param aLogger the logger to set
     */
    public static void setLogger(Logger aLogger) {
        logger = aLogger;
    }

    
    //private String                      pathToSoftware              = "";

    private             String          pathToMethRatioPy           = "";
    private             String          rootDataFolder              = "";
    private             String          ReferenceGenome             = "";

    
    private             Boolean         outputWiggleFile            = false;
    private             int             wiggleFileBinSize           = 25;
    private             String          processTheseChromosomes     = "all";
    private             String          pathToSAMTools              = "none";
    private             Boolean         onlyProcessUniqueMappings   = false;
    private             Boolean         onlyProcessPairedMappings   = false;
    private             Boolean         quietMode                   = false;
    private             Boolean         removeDuplicateReads        = false;
    private             int             trimNfillInNucleotides      = 0;
    private             Boolean         combineCPGsFromBothStrands  = false;
    private             int             minDepthCoverage            = 1;
    private             Boolean         noHeader                    = false;
    private             String          ctSnpAction                 = "correct";
    private             String          methylation_patterns        = "all";
    
    
    
    
    /**
     * 
     * @param sid StepInputData
     * 
     */
    public StepBSMapCalcMethRatios(StepInputData sid){
       stepInputData = sid;
    }
    
    
    
    /**
     * This parses out the hashmap containing the run parameters for this step
     * 
     * @param configData
     * @throws Exception 
     */
    @Override
    public void parseConfigurationData(HashMap configData) throws Exception{

        getLogger().info(STEP_ID_STRING + ": verify configuration data");
        
        /*
            the following parameters have to be specfied in the configuration file for the 
            analysis to proceed
        */
        if(configData == null || configData.get(ID_SOFTWARE)==null) {
            getLogger().info("<" + ID_SOFTWARE + "> : Missing Definition in Configuration File");
            getLogger().error("<" + ID_SOFTWARE + "> : Missing Definition in Configuration File");
            throw new NullPointerException("<" + ID_SOFTWARE + "> : Missing Definition in Configuration File");
        }
        if(configData.get(ID_REF_GENOME)==null) {
            getLogger().info("<" + configData.get(ID_REF_GENOME) + "> : Missing Definition in Configuration File");
            getLogger().error("<" + configData.get(ID_REF_GENOME) + "> : Missing Definition in Configuration File");
            throw new NullPointerException("<" + configData.get(ID_REF_GENOME) + "> : Missing Definition in Configuration File");
        }
        
        this.setReferenceGenome((String) configData.get(ID_REF_GENOME));
        if(this.getReferenceGenome().length() !=3 ){
            logger.error(ID_REF_GENOME + " <" + configData.get(ID_REF_GENOME) + "> must be a 3 letter string");            
            throw new IllegalArgumentException(ID_REF_GENOME + " <" + configData.get(ID_REF_GENOME) + "> must be a 3 letter string");            
        }

        this.setPathToMethRatioPy((String) configData.get(ID_SOFTWARE));        
        this.setPathToSAMTools((String) configData.get(ID_PATH_TO_SAMTOOLS));

        String chk;
        chk = checkParameter("Boolean", ID_OUTPUT_WIGGLE_FILE, Boolean.toString((Boolean)configData.get(ID_OUTPUT_WIGGLE_FILE)), "0", "NA", logger);
        if(chk!=null)
            this.setOutputWiggleFile((Boolean) configData.get(ID_OUTPUT_WIGGLE_FILE));        

        chk = checkParameter("Integer", ID_OUTPUT_WIGGLE_BINSIZE, Integer.toString((Integer)configData.get(ID_OUTPUT_WIGGLE_BINSIZE)), "1", "NA", logger);
        if(chk!=null)
            this.setWiggleFileBinSize((Integer)configData.get(ID_OUTPUT_WIGGLE_BINSIZE));

        chk = checkParameter("Integer", ID_TRIM_FILL_IN_NTS, Integer.toString((Integer)configData.get(ID_TRIM_FILL_IN_NTS)), "0", "NA", logger);
        if(chk!=null)
            this.setTrimNfillInNucleotides((Integer)configData.get(ID_TRIM_FILL_IN_NTS));

        chk = checkParameter("Integer", ID_MIN_DEPTH_COVERAGE, Integer.toString((Integer)configData.get(ID_MIN_DEPTH_COVERAGE)), "1", "NA", logger);
        if(chk!=null)
            this.setMinDepthCoverage((Integer)configData.get(ID_MIN_DEPTH_COVERAGE));

        chk = checkParameter("Boolean", ID_UNIQUE_MAPPINGS_ONLY, Boolean.toString((Boolean)configData.get(ID_UNIQUE_MAPPINGS_ONLY)), "0", "NA", logger);
        if(chk!=null)
            this.setOnlyProcessUniqueMappings((Boolean)configData.get(ID_UNIQUE_MAPPINGS_ONLY));
                         
        chk = checkParameter("Boolean", ID_PAIRED_MAPPINGS_ONLY, Boolean.toString((Boolean)configData.get(ID_PAIRED_MAPPINGS_ONLY)), "NA", "NA", logger);
        if(chk!=null){
            this.setOnlyProcessPairedMappings((Boolean)configData.get(ID_PAIRED_MAPPINGS_ONLY));
        }
        
        chk = checkParameter("Boolean", ID_REMOVE_DUPLICATE_READS, Boolean.toString((Boolean)configData.get(ID_REMOVE_DUPLICATE_READS)), "NA", "NA", logger);
        if(chk!=null){
            this.setRemoveDuplicateReads((Boolean)configData.get(ID_REMOVE_DUPLICATE_READS));
        }
        
        chk = checkParameter("Boolean", ID_QUIET_MODE, Boolean.toString((Boolean)configData.get(ID_QUIET_MODE)), "NA", "NA", logger);
        if(chk!=null){
            this.setRemoveDuplicateReads((Boolean)configData.get(ID_QUIET_MODE));
        }
        
        chk = checkParameter("Boolean", ID_COMBINE_STRANDS, Boolean.toString((Boolean)configData.get(ID_COMBINE_STRANDS)), "NA", "NA", logger);
        if(chk!=null){
            this.setCombineCPGsFromBothStrands((Boolean)configData.get(ID_COMBINE_STRANDS));
        }
        
        chk = checkParameter("Boolean", ID_NO_HEADER, Boolean.toString((Boolean)configData.get(ID_NO_HEADER)), "NA", "NA", logger);
        if(chk!=null){
            this.setNoHeader((Boolean)configData.get(ID_NO_HEADER));
        }
                    
        if(this.checkMethylationPattern((String)configData.get(ID_METHYLATION_PATTERNS))){
            this.setMethylation_patterns((String)configData.get(ID_METHYLATION_PATTERNS));
        }

        if(this.checkChromosomeList((String)configData.get(ID_PROCESS_THESE_CHRS))){
            this.setProcessTheseChromosomes((String)configData.get(ID_PROCESS_THESE_CHRS));
        }
            
        if(this.checkCT_SNPParameter((String)configData.get(ID_CT_SNP_ACTION))){
            this.setCtSnpAction((String)configData.get(ID_CT_SNP_ACTION));
        }
            

        getLogger().info("passed");
    }
    
    
    
    /**
     * Check the specified Methylation patterns make sense
     *  -x TYPE, --context=TYPE
     *                  methylation pattern type [CG|CHG|CHH], multiple types
     *                  separated by ','. [default: all]
     * 
     * @param seq
     * @return 
     */
    private Boolean checkMethylationPattern(String methPatternString) throws Exception{
        
        String [] methOpts = {"CG", "CHG", "CHH"};
        if(methPatternString.equals("all")){
            return true;
        }else{
            for(String methPattern: methPatternString.split(",")){
                if(ArrayUtils.contains(methOpts, methPattern.trim())==false){
                    logger.info("Unrecognized Methylation Pattern <" + methPattern + ">" + " can only be [CG|CHG|CHH]");            
                    logger.error("Unrecognized Methylation Pattern <" + methPattern + ">" + " can only be [CG|CHG|CHH]");   
                    throw new Exception("Unrecognized Methylation Pattern <" + methPattern + ">" + " can only be [CG|CHG|CHH]");                    
                }
            }
        }
        return true;
    }
    



    /**
     * Check the specified CT_SNP value make sense
     *   -i CT_SNP, --ct-snp=CT_SNP
                        how to handle CT SNP ("no-action", "correct", "skip"),
                        default: "correct".
     * 
     * @param seq
     * @return 
     */
    private Boolean checkCT_SNPParameter(String ctsnpString) throws Exception{
        
        String [] ctsnpOpts = {"no-action", "correct", "skip"};
        if(ArrayUtils.contains(ctsnpOpts, ctsnpString.trim())==false){
            logger.info("Unrecognized CT_SNP parameter <" + ctsnpString + ">" 
                    + " can only be [no-action|correct|skip]");            
            logger.error("Unrecognized CT_SNP parameter <" + ctsnpString + ">" 
                    + " can only be [no-action|correct|skip]");   
            throw new Exception("Unrecognized CT_SNP parameter <" + ctsnpString + ">" 
                    + " can only be [no-action|correct|skip]");                    
        }
        return true;
    }
    



    /**
     * Check the specified Chromosome List makes sense:
     * 
     *  -c CHR, --chr=CHR     process only specified chromosomes, separated by ','.
     *                  [default: all] example: --chroms=chr1,chr2
     * 
     * @return 
     */
    private Boolean checkChromosomeList(String chrListString) throws Exception{
        
        if(chrListString.trim().equals("all")){
            return true;
        }else{
            if(chrListString.split(",").length!=0){
                logger.info("Couldn't parse Chromosome list <" + this.getMethylation_patterns() + ">\n" 
                        + "This should be a comma delimited list, e.g 'chr1, chr2, ....>'");            
                logger.error("Couldn't parse Chromosome list <" + this.getMethylation_patterns() + ">\n" 
                        + "This should be a comma delimited list, e.g 'chr1, chr2, ....>'");   
                throw new Exception("Couldn't parse Chromosome list <" + this.getMethylation_patterns() + ">\n" 
                        + "This should be a comma delimited list, e.g 'chr1, chr2, ....>'");                    
            }
        }
        return true;
    }
        



    /**
     * BSMap single or paired end reads
     * Still need to add ability to include multiple adapter sequences
     * 
     * @throws IOException 
     */
    @Override
    public void execute() throws IOException{
        /* example call.:
            python /usr/local/bin/methratio.py 
                sortedPilot1.bam 
                -d ../../../../../../Volumes/LaCie_kari/ref/Homo_sapiens_assembly19.fasta  
                -p 
                -s  ../../samtools0.1.19/ 
                -o sortedPilot1-2.txt &

        */
        getLogger().info(STEP_ID_STRING + ": execute step");        
        
        Boolean fA = new File(outFolder).mkdir();
        if (fA) {
            logger.info("created output folder <" + outFolder + "> for results");
        }
        
        // 
        Iterator itSD = this.stepInputData.getSampleData().iterator();
        while (itSD.hasNext()){
            try{
                SampleDataEntry sampleData = (SampleDataEntry)itSD.next();                
                
                String cmdCalcMethRatios = "";   
                ArrayList<String> cmd = new ArrayList<>();
                cmd.add(this.getPathToMethRatioPy());
                
                
                String pathToGenomeFA = this.cleanPath(stepInputData.getDataLocations().getGenomeRootFolder()
                        + FILESEPARATOR + this.getReferenceGenome() + FILESEPARATOR + ReferenceDataLocations.ID_REL_WHOLE_GENSEQ_FA);
                cmd.add("-d " + pathToGenomeFA);
                    
                /**
                 * not sure about the best way to handle this.
                 * It seems that the files that come of the NSC sequences have a general format
                 * SAMPLENAME_SEQUENCERDATA1_SEQUENCEDATA_..., so we split at the first "_"
                 * 
                 */
                String methOutFile = this.cleanPath(outFolder + FILESEPARATOR 
                        + sampleData.getFastqFile1().split("_")[0].trim()+ METHFILE_EXTENSION);
                
                cmd.add("-o " + methOutFile);
                
                if(this.getOutputWiggleFile()){
                    String wiggleFile = methOutFile.replace(METHFILE_EXTENSION, WIGGLEFILE_EXTENSION);
                    cmd.add("-w " + wiggleFile);                
                    cmd.add("-b " + this.getWiggleFileBinSize());                
                }
                cmd.add("-c " + this.getProcessTheseChromosomes());
                
                if(this.getPathToSAMTools().isEmpty()==false)
                    cmd.add("-s " + this.getPathToSAMTools());
                
                
                if(this.getOnlyProcessUniqueMappings())
                    cmd.add("-u");
                if(this.getOnlyProcessPairedMappings())
                    cmd.add("-p");
                if(this.getQuietMode())
                    cmd.add("-q");
                if(this.getRemoveDuplicateReads())
                    cmd.add("-r");
                if(this.getCombineCPGsFromBothStrands())
                    cmd.add("-g");
                if(this.getNoHeader())
                    cmd.add("-n");
                
                String samAlnFile = this.cleanPath(inFolder + FILESEPARATOR 
                    + sampleData.getFastqFile1().split("_")[0].trim() + INFILE_EXTENSION);
                cmd.add(samAlnFile);
                
                                
                cmdCalcMethRatios = this.cleanPath(StringUtils.join(cmd, " "));
                logger.info("methylratio command is: " + cmdCalcMethRatios);
                Runtime rt = Runtime.getRuntime();
                Process proc = rt.exec(cmdCalcMethRatios);
                BufferedReader brAStdin = new BufferedReader(new InputStreamReader(proc.getInputStream()));
                BufferedReader brAStdErr = new BufferedReader(new InputStreamReader(proc.getErrorStream()));

                String line = null;
                logger.info("<OUTPUT>");
                while ((line = brAStdin.readLine()) != null) {
                    logger.info(line);
                }
                logger.info("</OUTPUT>");

                logger.info("<ERROR>");
                int skipCount = 0;
                
                ArrayList<String>  mapAbunStdErr;

                mapAbunStdErr = new ArrayList<>();
                while ((line = brAStdErr.readLine()) != null) {
                        logger.info(line);
                        mapAbunStdErr.add(line);
                }
                

                logger.info("</ERROR>");

                int exitVal = proc.waitFor();
                logger.info("Process exitValue: " + exitVal);

                brAStdin.close();
                brAStdErr.close();
                logger.info(STEP_ID_STRING + ": done");
                
                String samAlnOutput = this.cleanPath(outFolder + FILESEPARATOR 
                    + sampleData.getFastqFile1().split("_")[0].trim()+".methratio_output");
                try(BufferedWriter bwAO = new BufferedWriter(new FileWriter(new File(samAlnOutput)))){
                    for(String logString:mapAbunStdErr){
                        bwAO.write(logString + "\n");
                    }
                }
                catch(IOException exIO){
                    logger.error("error writing methratio summary file <" + samAlnOutput +  ">");
                    logger.info("error writing methratio summary file <" + samAlnOutput +  ">");
                    throw new IOException("error writing methratio summary file <" + samAlnOutput +  ">" + exIO);
                }
                
                
            }
            catch(IOException | InterruptedException ex ){
                getLogger().info("error executing methratio program:\n" + ex.toString());
                getLogger().error("error executing methratio program:\n" + ex.toString());
                throw new IOException("error executing methratio program");
            }
        }
        
        getLogger().info(STEP_ID_STRING + ": completed");
    }
    
    
    
            
    /**
     * this should be called prior to executing the step.
     * check unzip software exists and input files are available
     * 
     * @throws IOException
     */
    @Override
    public void verifyInputData() throws IOException{
        
        getLogger().info("verify input data");        
        this.setPaths();
        
        if(new File(this.getPathToMethRatioPy()).exists() == false){
            getLogger().info("methratio.py not found at location < " + this.getPathToMethRatioPy() +">");
            getLogger().error("methratio.py not found at location < " + this.getPathToMethRatioPy() +">");
            throw new IOException("methratio.py not found at location < " + this.getPathToMethRatioPy() +">");
        }
                
        String pathToGenomeFA = this.cleanPath(stepInputData.getDataLocations().getGenomeRootFolder()
                + FILESEPARATOR + this.getReferenceGenome() + FILESEPARATOR + ReferenceDataLocations.ID_REL_WHOLE_GENSEQ_FA);                
        if(new File(pathToGenomeFA).exists() == false){
            logger.error("genome FA file < " + pathToGenomeFA +"> not found");
            logger.info("genome FA file < " + pathToGenomeFA +"> not found");
            throw new IOException("genome FA file < " + pathToGenomeFA +"> not found");
        }
                            
        for(SampleDataEntry sampleData: this.stepInputData.getSampleData()){
            
            

            /**
             * not sure about the best way to handle this.
             * It seems that the files that come of the NSC sequences have a general format
                 * SAMPLENAME_SEQUENCERDATA1_SEQUENCEDATA_..., so we split at the first "_"
                 * 
                 */
            //Fastq 1
            if (sampleData.getFastqFile1()==null) {
                getLogger().error("no Fastq1 file specified");
                throw new IOException("no Fastq1 file specified");
            }
            
            String alnFile = this.cleanPath(inFolder + FILESEPARATOR 
                    + sampleData.getFastqFile1().split("_")[0].trim()+".sam");

            //fastqFile1out = this.cleanPath(inFolder + FILESEPARATOR + sampleData.getFastqFile1());
            Boolean correctExt = false;
            for(String end:INFILE_EXTENSION.split("/")){
                if (alnFile.toUpperCase().endsWith(end.toUpperCase())==true) {
                    correctExt = true;
                    break;
                }     
            }
            if (!correctExt){
                getLogger().info(STEP_ID_STRING + ": incorrect file extension for input alignment file <" 
                  + alnFile + ">. should have <" + INFILE_EXTENSION + "> as extension");
                getLogger().error(STEP_ID_STRING + ": incorrect file extension for input alignment file <" 
                  + alnFile + ">. should have <" + INFILE_EXTENSION + "> as extension");
                throw new IOException(STEP_ID_STRING + ": incorrect file extension for input alignment file <" 
                  + alnFile + ">.\n should have <" + INFILE_EXTENSION + "> as extension");
            }
            
            if (new File(alnFile).exists()==false){
                getLogger().error(STEP_ID_STRING + ": input alignment file <" + alnFile + "> does not exist");
                throw new IOException(STEP_ID_STRING + ": input alignment file <" + alnFile + "> does not exist");
            }
                       

        }
        logger.info("passed");
    }
    
    
    
    @Override
    public void verifyOutputData(){
        getLogger().info("no output verification required");
    }
    
    
    
    /**
     * generate sample configuration data so the user can see what can be 
     * specified 
     * 
     * @return 
     */
    @Override
    public HashMap generateExampleConfigurationData() {

        getLogger().info(STEP_ID_STRING + ": generate example configuration data");
        
        HashMap configData = new HashMap();
        
        configData.put(ID_SOFTWARE, "/usr/local/bin/methratio.py");
        configData.put(ID_REF_GENOME, "hsa");
        configData.put(ID_OUTPUT_WIGGLE_FILE, true);
        
        configData.put(ID_OUTPUT_WIGGLE_BINSIZE, 25);
        configData.put(ID_PROCESS_THESE_CHRS, "all");
        configData.put(ID_PATH_TO_SAMTOOLS, "");
        configData.put(ID_UNIQUE_MAPPINGS_ONLY, false);
        configData.put(ID_PAIRED_MAPPINGS_ONLY, true);
        configData.put(ID_QUIET_MODE, true);
        configData.put(ID_REMOVE_DUPLICATE_READS, true);
        configData.put(ID_TRIM_FILL_IN_NTS, 0);
        configData.put(ID_COMBINE_STRANDS, false);
        configData.put(ID_MIN_DEPTH_COVERAGE, 1);
        configData.put(ID_NO_HEADER, false);
        configData.put(ID_CT_SNP_ACTION, "correct");
        configData.put(ID_METHYLATION_PATTERNS, "all");

        return configData;
        
    }
    
    
    

    /**
     * @return the pathToBSMap
     */
    public String getPathToMethRatioPy() {
        return pathToMethRatioPy;
    }

    /**
     * @param pathToBSMap the pathToBSMap to set
     */
    public void setPathToMethRatioPy(String pathToBSMap) {
        this.pathToMethRatioPy = pathToBSMap;
    }

    /**
     * @return the rootDataFolder
     */
    public String getRootDataFolder() {
        return rootDataFolder;
    }

    /**
     * @param rootDataFolder the rootDataFolder to set
     */
    public void setRootDataFolder(String rootDataFolder) {
        this.rootDataFolder = rootDataFolder;
    }

    /**
     * @return the ReferenceGenome
     */
    public String getReferenceGenome() {
        return ReferenceGenome;
    }

    /**
     * @param ReferenceGenome the ReferenceGenome to set
     */
    public void setReferenceGenome(String ReferenceGenome) {
        this.ReferenceGenome = ReferenceGenome;
    }

    /**
     * @return the outputWiggleFile
     */
    public Boolean getOutputWiggleFile() {
        return outputWiggleFile;
    }

    /**
     * @param outputWiggleFile the outputWiggleFile to set
     */
    public void setOutputWiggleFile(Boolean outputWiggleFile) {
        this.outputWiggleFile = outputWiggleFile;
    }

    /**
     * @return the wiggleFileBinSize
     */
    public int getWiggleFileBinSize() {
        return wiggleFileBinSize;
    }

    /**
     * @param wiggleFileBinSize the wiggleFileBinSize to set
     */
    public void setWiggleFileBinSize(int wiggleFileBinSize) {
        this.wiggleFileBinSize = wiggleFileBinSize;
    }

    /**
     * @return the processTheseChromosomes
     */
    public String getProcessTheseChromosomes() {
        return processTheseChromosomes;
    }

    /**
     * @param chromString the processTheseChromosomes to set
     */
    public void setProcessTheseChromosomes(String chromString) {
        processTheseChromosomes = chromString;
    }

    /**
     * @return the pathToSAMTools
     */
    public String getPathToSAMTools() {
        return pathToSAMTools;
    }

    /**
     * @param pathToSAMTools the pathToSAMTools to set
     */
    public void setPathToSAMTools(String pathToSAMTools) {
        this.pathToSAMTools = pathToSAMTools;
    }

    /**
     * @return the onlyProcessUniqueMappings
     */
    public Boolean getOnlyProcessUniqueMappings() {
        return onlyProcessUniqueMappings;
    }

    /**
     * @param onlyProcessUniqueMappings the onlyProcessUniqueMappings to set
     */
    public void setOnlyProcessUniqueMappings(Boolean onlyProcessUniqueMappings) {
        this.onlyProcessUniqueMappings = onlyProcessUniqueMappings;
    }

    /**
     * @return the onlyProcessPairedMappings
     */
    public Boolean getOnlyProcessPairedMappings() {
        return onlyProcessPairedMappings;
    }

    /**
     * @param onlyProcessPairedMappings the onlyProcessPairedMappings to set
     */
    public void setOnlyProcessPairedMappings(Boolean onlyProcessPairedMappings) {
        this.onlyProcessPairedMappings = onlyProcessPairedMappings;
    }

    /**
     * @return the quietMode
     */
    public Boolean getQuietMode() {
        return quietMode;
    }

    /**
     * @param quietMode the quietMode to set
     */
    public void setQuietMode(Boolean quietMode) {
        this.quietMode = quietMode;
    }

    /**
     * @return the removeDuplicateReads
     */
    public Boolean getRemoveDuplicateReads() {
        return removeDuplicateReads;
    }

    /**
     * @param removeDuplicateReads the removeDuplicateReads to set
     */
    public void setRemoveDuplicateReads(Boolean removeDuplicateReads) {
        this.removeDuplicateReads = removeDuplicateReads;
    }

    /**
     * @return the trimNfillInNucleotides
     */
    public int getTrimNfillInNucleotides() {
        return trimNfillInNucleotides;
    }

    /**
     * @param trimNfillInNucleotides the trimNfillInNucleotides to set
     */
    public void setTrimNfillInNucleotides(int trimNfillInNucleotides) {
        this.trimNfillInNucleotides = trimNfillInNucleotides;
    }

    /**
     * @return the combineCPGsFromBothStrands
     */
    public Boolean getCombineCPGsFromBothStrands() {
        return combineCPGsFromBothStrands;
    }

    /**
     * @param combineCPGsFromBothStrands the combineCPGsFromBothStrands to set
     */
    public void setCombineCPGsFromBothStrands(Boolean combineCPGsFromBothStrands) {
        this.combineCPGsFromBothStrands = combineCPGsFromBothStrands;
    }

    /**
     * @return the minDepthCoverage
     */
    public int getMinDepthCoverage() {
        return minDepthCoverage;
    }

    /**
     * @param minDepthCoverage the minDepthCoverage to set
     */
    public void setMinDepthCoverage(int minDepthCoverage) {
        this.minDepthCoverage = minDepthCoverage;
    }

    /**
     * @return the noHeader
     */
    public Boolean getNoHeader() {
        return noHeader;
    }

    /**
     * @param noHeader the noHeader to set
     */
    public void setNoHeader(Boolean noHeader) {
        this.noHeader = noHeader;
    }

    /**
     * @return the ctSnpAction
     */
    public String getCtSnpAction() {
        return ctSnpAction;
    }

    /**
     * @param ctSnpAction the ctSnpAction to set
     */
    public void setCtSnpAction(String ctSnpAction) {
        this.ctSnpAction = ctSnpAction;
    }

    /**
     * @return the methylation_patterns
     */
    public String getMethylation_patterns() {
        return methylation_patterns;
    }

    /**
     * @param methylation_patterns the methylation_patterns to set
     */
    public void setMethylation_patterns(String methylation_patterns) {
        this.methylation_patterns = methylation_patterns;
    }

    
    
}
